##an implementation of the poisson-beta-binomial likelihood fnc. that is specific to the imagery model
##TODO: a function for converting alpha/beta to theta_on, theta_off and back again
from numpy import array,zeros,sum

def alpha_beta_2_on_off(alpha, beta):
  on_prob = (alpha+1)/(alpha+beta+1)
  off_prob = (alpha)/(alpha+beta+1)
  return on_prob, off_prob
  
def on_off_2_alpha_beta(on_prob, off_prob):
  alpha = -off_prob/(off_prob-on_prob)
  beta = (off_prob-1)/(off_prob-on_prob) - 1
  return alpha, beta


class poisson_beta_binomial(object):
  def __init__(self, number_of_objects, **kwargs):
    '''
    poisson_beta_binomial(number_of_objects, <alpha_beta = (0,0) \ on_off_prob = (1,0)>)
    we assume there are a certain number of objects in every region of a mental image
    whenever we probe a local region of the mental image object map, we get an array of "on_offs"
    we assume that responses are generated by sampling from a binomial with probability
    alpha + kj / (alpha + beta + 1), where kj indicates whether the probe overlaps the jth object
    we can parametrize the distribution using either keyword argument:
      alpha_beta = (alpha, beta)  ~ must both be >= 0.
      on_off_prob = (on_prob, off_prob) ~ must satisfy 0 <= off_prob < on_prob <= 1.
    '''
    
    self.__n__ = number_of_objects
    self.parameter_conversion(**kwargs) ##sets alpha/beta, on_prob/off_prob attributes
    if not self.__check_args__():
      raise Exception('poisson_beta_binomial: check your arguments fool')
    self.__construct_sets__()
    
  def __construct_sets__(self):
    import itertools
    self.__A__ = []
    self.__Ac__ = []
    for ii in range(self.__n__+1):
      subset = map(set, itertools.combinations(range(self.__n__),ii))
      complement = map(set(range(self.__n__)).difference, subset)
      self.__A__ += [map(list, subset)]
      self.__Ac__ += [map(list,complement)]
   
  def __check_args__(self):
    if self.on_prob > 1:
      return 0
    if self.on_prob < 0:
      return 0
    if self.off_prob >= self.on_prob:
      return 0
    if self.off_prob < 0:
      return 0
    if self.alpha < 0:
      return 0
    if self.beta < 0:
      return 0
    return 1
    
  def parameter_conversion(self, **kwargs):
    for key in kwargs:
      if key is 'alpha_beta':
	self.alpha = kwargs[key][0]
	self.beta = kwargs[key][1]
	self.on_prob, self.off_prob = alpha_beta_2_on_off(self.alpha, self.beta)
      elif key is 'on_off_prob':
	self.on_prob = kwargs[key][0]
	self.off_prob = kwargs[key][1]
	self.alpha, self.beta = on_off_2_alpha_beta(self.on_prob, self.off_prob)

  def likelihood(self, r, on_offs, on_off_prob = None):
    '''
    likelihood(responses, on_offs)
    the likelihood of a sujbect's responses given the overlap between their mental image and a probe
    r ~ number_of_trials x 1 integer array, r = [0,...,number_of_objects]
    on_offs ~ number_of_trials x number_of_objects, each row ~ binary matrix with 0 <= sum_across_cols <= number_of_objects
    output ~ number_of_trials x 1
    '''
    
    if on_off_prob is None:
      alpha = self.alpha
      beta = self.beta
    else:
      alpha, beta = on_off_2_alpha_beta(on_off_prob[0], on_off_prob[1])
    number_of_trials = len(r)
    pb = zeros((number_of_trials,1))
    #print 'fkar'
    for ii,resp in enumerate(r):
      probs = array(map(lambda x: (alpha+x)/(alpha+beta+1.), on_offs[ii,:]))
      #pb[ii] = 0
      
      for j,l in zip(self.__A__[resp],self.__Ac__[resp]):
	pb[ii] += probs[j].prod()*(1-probs[l]).prod()
      #pb[ii] = sum(map(lambda j,l: probs[j].prod()*(1-probs[l]).prod(), self.__A__[resp],self.__Ac__[resp]))
    return pb
    
  def sum_log_likelihood(self, r, on_offs, on_off_prob = None):
    from numpy import sum, log
    return sum(log(self.likelihood(r,on_offs,on_off_prob)))

  def sample(self, on_offs):
    '''
    sample responses from a binomial for each object
    parameters for each sample are n = 1, and p = (alpha+k)/(alpha+beta+1), where k ~ [0,1]
    '''
    from numpy import sum, array, atleast_2d
    from numpy.random import binomial
    alpha = self.alpha
    beta = self.beta
    return atleast_2d(sum([[binomial(1, (alpha+k)/(alpha+beta+1)) for k in ii] for ii in on_offs],axis=1)).T
    


   
   

   